// generated by mBlock5 for <your product>
// codes make you happy

#include <Arduino.h>
#include <Wire.h>
#include <SoftwareSerial.h>

float MOTOR1_A1 = 0;
float MOTOR1_A2 = 0;
float MOTOR1_EN = 0;
float MOTOR2_B1 = 0;
float MOTOR2_B2 = 0;
float MOTOR2_EN = 0;
float COUNT_MOTOR_1 = 0;
float COUNT_MOTOR_2 = 0;
float STEPS_PER_REV2 = 0;
float GLOBAL_REV_COUNT_1 = 0;
float GLOBAL_REV_COUNT_2 = 0;
float SPEED = 0;
float STEPS_PER_REV1 = 0;

void Reverse_N (double revolutions){
  COUNT_MOTOR_1 = 0;
  COUNT_MOTOR_2 = 0;
  analogWrite(MOTOR1_EN,0);
  analogWrite(MOTOR2_EN,0);
  digitalWrite(MOTOR1_A1,1);
  digitalWrite(MOTOR1_A2,0);
  digitalWrite(MOTOR2_B1,1);
  digitalWrite(MOTOR2_B2,0);
  while(!((COUNT_MOTOR_1 > (revolutions * STEPS_PER_REV1))  &&  (COUNT_MOTOR_2 > (revolutions * STEPS_PER_REV2))))
  {
    Serial.print("Motor 1: ");
    Serial.print(COUNT_MOTOR_1);
    Serial.print(" Motor 2: ");
    Serial.print(COUNT_MOTOR_2);
    Serial.print(" Revolutions: ");
    Serial.print(revolutions);
    Serial.print(" Motor Count 1: ");
    Serial.print(STEPS_PER_REV1 * revolutions);
    Serial.print(" Motor Count 2: ");
    Serial.println(STEPS_PER_REV2 * revolutions);
    _loop();
    if((revolutions * STEPS_PER_REV1) > COUNT_MOTOR_1){
        if(!(((COUNT_MOTOR_1 / STEPS_PER_REV1) > (COUNT_MOTOR_2 / STEPS_PER_REV2)))){
            analogWrite(MOTOR1_EN,SPEED);

        }else{
            if((COUNT_MOTOR_1 / STEPS_PER_REV1) == (COUNT_MOTOR_2 / STEPS_PER_REV2)){
                analogWrite(MOTOR1_EN,SPEED);

            }else{
                analogWrite(MOTOR1_EN,0);

            }

        }

    }else{
        analogWrite(MOTOR1_EN,0);

    }
    if((revolutions * STEPS_PER_REV2) > COUNT_MOTOR_2){
        if(!(((COUNT_MOTOR_2 / STEPS_PER_REV2) > (COUNT_MOTOR_1 / STEPS_PER_REV1)))){
            analogWrite(MOTOR2_EN,SPEED);

        }else{
            if((COUNT_MOTOR_2 / STEPS_PER_REV2) == (COUNT_MOTOR_1 / STEPS_PER_REV1)){
                analogWrite(MOTOR2_EN,SPEED);

            }else{
                analogWrite(MOTOR2_EN,0);

            }

        }

    }else{
        analogWrite(MOTOR2_EN,0);

    }

  }
  analogWrite(MOTOR1_EN,0);
  analogWrite(MOTOR2_EN,0);
  GLOBAL_REV_COUNT_2 = 0;
  GLOBAL_REV_COUNT_1 = 0;

}

void Left_Wheel_N (double revolutions){
  GLOBAL_REV_COUNT_1 = revolutions;
  COUNT_MOTOR_1 = 0;
  COUNT_MOTOR_2 = 0;
  analogWrite(MOTOR1_EN,0);
  analogWrite(MOTOR2_EN,0);
  digitalWrite(MOTOR1_A1,1);
  digitalWrite(MOTOR1_A2,0);
  digitalWrite(MOTOR2_B1,0);
  digitalWrite(MOTOR2_B2,0);
  while(!(COUNT_MOTOR_1 > (revolutions * STEPS_PER_REV2)))
  {
    Serial.print("Motor 1: ");
    Serial.print(COUNT_MOTOR_1);
    Serial.print(" Motor 2: ");
    Serial.print(COUNT_MOTOR_2);
    Serial.print(" Revolutions: ");
    Serial.print(revolutions);
    Serial.print(" Motor Count 1: ");
    Serial.print(STEPS_PER_REV1 * revolutions);
    Serial.print(" Motor Count 2: ");
    Serial.println(STEPS_PER_REV2 * revolutions);
    _loop();
    if((revolutions * STEPS_PER_REV1) > COUNT_MOTOR_1){
        analogWrite(MOTOR1_EN,SPEED);

    }else{
        analogWrite(MOTOR1_EN,0);

    }

  }
  GLOBAL_REV_COUNT_1 = 0;
  analogWrite(MOTOR1_EN,0);
  analogWrite(MOTOR2_EN,0);

}
void ISR_FALLING_2_() {
    COUNT_MOTOR_1 += 1;
}
void ISR_FALLING_3_1() {
    COUNT_MOTOR_2 += 1;
}
void stop (){
  digitalWrite(MOTOR1_A1,0);
  digitalWrite(MOTOR1_A2,1);
  digitalWrite(MOTOR2_B1,0);
  digitalWrite(MOTOR2_B2,1);
  analogWrite(MOTOR1_EN,0);
  analogWrite(MOTOR2_EN,0);
  GLOBAL_REV_COUNT_2 = 0;
  GLOBAL_REV_COUNT_1 = 0;

}
void Forward_N (double revolutions){
  COUNT_MOTOR_1 = 0;
  COUNT_MOTOR_2 = 0;
  analogWrite(MOTOR1_EN,0);
  analogWrite(MOTOR2_EN,0);
  digitalWrite(MOTOR1_A1,0);
  digitalWrite(MOTOR1_A2,1);
  digitalWrite(MOTOR2_B1,0);
  digitalWrite(MOTOR2_B2,1);
  while(!((COUNT_MOTOR_1 > (revolutions * STEPS_PER_REV1))  &&  (COUNT_MOTOR_2 > (revolutions * STEPS_PER_REV2))))
  {
    Serial.print("Motor 1: ");
    Serial.print(COUNT_MOTOR_1);
    Serial.print(" Motor 2: ");
    Serial.print(COUNT_MOTOR_2);
    Serial.print(" Revolutions: ");
    Serial.print(revolutions);
    Serial.print(" Motor Count 1: ");
    Serial.print(STEPS_PER_REV1 * revolutions);
    Serial.print(" Motor Count 2: ");
    Serial.println(STEPS_PER_REV2 * revolutions);
    _loop();
    if((revolutions * STEPS_PER_REV1) > COUNT_MOTOR_1){
        if(!(((COUNT_MOTOR_1 / STEPS_PER_REV1) > (COUNT_MOTOR_2 / STEPS_PER_REV2)))){
            analogWrite(MOTOR1_EN,SPEED);

        }else{
            if((COUNT_MOTOR_1 / STEPS_PER_REV1) == (COUNT_MOTOR_2 / STEPS_PER_REV2)){
                analogWrite(MOTOR1_EN,SPEED);

            }else{
                analogWrite(MOTOR1_EN,0);

            }

        }

    }else{
        analogWrite(MOTOR1_EN,0);

    }
    if((revolutions * STEPS_PER_REV2) > COUNT_MOTOR_2){
        if(!(((COUNT_MOTOR_2 / STEPS_PER_REV2) > (COUNT_MOTOR_1 / STEPS_PER_REV1)))){
            analogWrite(MOTOR2_EN,SPEED);

        }else{
            if((COUNT_MOTOR_2 / STEPS_PER_REV2) == (COUNT_MOTOR_1 / STEPS_PER_REV1)){
                analogWrite(MOTOR2_EN,SPEED);

            }else{
                analogWrite(MOTOR2_EN,0);

            }

        }

    }else{
        analogWrite(MOTOR2_EN,0);

    }

  }
  GLOBAL_REV_COUNT_2 = 0;
  GLOBAL_REV_COUNT_1 = 0;
  analogWrite(MOTOR1_EN,0);
  analogWrite(MOTOR2_EN,0);

}
void Right_Wheel_N (double revolutions){
  GLOBAL_REV_COUNT_2 = revolutions;
  COUNT_MOTOR_1 = 0;
  COUNT_MOTOR_2 = 0;
  analogWrite(MOTOR1_EN,0);
  analogWrite(MOTOR2_EN,0);
  digitalWrite(MOTOR1_A1,0);
  digitalWrite(MOTOR1_A2,0);
  digitalWrite(MOTOR2_B1,1);
  digitalWrite(MOTOR2_B2,0);
  while(!(COUNT_MOTOR_2 > (revolutions * STEPS_PER_REV2)))
  {
    
    Serial.print("Motor 1: ");
    Serial.print(COUNT_MOTOR_1);
    Serial.print(" Motor 2: ");
    Serial.print(COUNT_MOTOR_2);
    Serial.print(" Revolutions: ");
    Serial.print(revolutions);
    Serial.print(" Motor Count 1: ");
    Serial.print(STEPS_PER_REV1 * revolutions);
    Serial.print(" Motor Count 2: ");
    Serial.println(STEPS_PER_REV2 * revolutions);
    _loop();
    if((revolutions * STEPS_PER_REV2) > COUNT_MOTOR_2){
        analogWrite(MOTOR2_EN,SPEED);

    }else{
        analogWrite(MOTOR2_EN,0);

    }

  }
  GLOBAL_REV_COUNT_2 = 0;
  analogWrite(MOTOR1_EN,0);
  analogWrite(MOTOR2_EN,0);

}

void _delay(float seconds) {
  long endTime = millis() + seconds * 1000;
  while(millis() < endTime) _loop();
}

void _delayMilliseconds(float milliseconds) {
  long endTime = millis() + milliseconds;
  while(millis() < endTime) _loop();
}

void setup() {
  pinMode(MOTOR1_EN,OUTPUT);
  pinMode(MOTOR2_EN,OUTPUT);
  pinMode(MOTOR1_A1,OUTPUT);
  pinMode(MOTOR1_A2,OUTPUT);
  pinMode(MOTOR2_B1,OUTPUT);
  pinMode(MOTOR2_B2,OUTPUT);
  pinMode(2, INPUT);
  pinMode(3, INPUT);

  Serial.begin(9600);

  SPEED = 100;
  STEPS_PER_REV1 = 20;
  STEPS_PER_REV2 = 20;
  MOTOR1_A1 = 9;
  MOTOR1_A2 = 8;
  MOTOR1_EN = 11;
  MOTOR2_B1 = 12;
  MOTOR2_B2 = 7;
  MOTOR2_EN = 5;
  COUNT_MOTOR_1 = 0;
  COUNT_MOTOR_2 = 0;
  attachInterrupt(0, ISR_FALLING_2_, FALLING);
  attachInterrupt(1, ISR_FALLING_3_1, FALLING);
  _delay(3);
  Forward_N(20);

}

void _loop() {
}

void loop() {

}
